将研究 java.util.concurrent 包中的 Phaser 构造。它与 CountDownLatch 非常相似，允许我们协调线程的执行。与 CountDownLatch 相比，它具有一些附加功能

Phaser 是一个屏障，动态线程数在继续执行之前需要等待。在 CountDownLatch 中，该数字无法动态配置，必须在创建实例时提供

Phaser 允许我们构建逻辑，在该逻辑中，线程需要在进入下一步执行之前等待屏障。

我们可以协调执行的多个阶段，为每个程序阶段重用一个 Phaser 实例。每个阶段可以有不同数量的线程等待前进到另一个阶段。我们稍后会看一个使用阶段的示例。

要参与协调，线程需要向 Phaser 实例register() 自身。请注意，这只会增加注册方的数量，我们无法检查当前线程是否已注册 - 我们必须对实现进行子类化以支持这一点。

线程通过调用 arriveAndAwaitAdvance（） 来发出信号，表明它到达了屏障，这是一种阻塞方法。当**到达的当事方数量等于注册当事方的数量**时，程序的执行将继续，阶段数将增加。我们可以通过调用 getPhase（） 方法获取当前阶段数。

当线程完成其工作时，我们应该调用 arriveAndDeregister（） 方法来表示不应再在此特定阶段考虑当前线程。

